kong、keycloak、APIマッシュアップという構成で、
service-a,service-bがあるときに、APIマッシュアップさせ、それぞれ多段認可させたい。


---

ナイス！ここまで通ったので、次は\*\*“APIマッシュアップ + 多段認可”\*\*をきれいに組み立てましょう。
全体像はこうです：

> ユーザー → Kong `/mashup` → Quarkus(集約API) がログインを要求
> → Quarkus が **ユーザーのトークン**を持って **Service A/B** を呼び出し
> → それぞれのサービス側でも **自分のポリシー**で認可（多段）
> → 結果をマージして返す

下に**実装の最短ルート**を書きます。すでに動いている構成からの差分だけ説明します。

---

# 設計のポイント（先に結論）

* **認証は入口(Quarkus集約API)で一回**（OIDC: Keycloak）
* **認可は二段**

  1. 集約API内で「A/Bを呼んで良いユーザーか」をチェック
  2. 下流の Service A / Service B それぞれでも**自前の認可**（役割/スコープ）
* **トークンの受け渡し**：Quarkus が**ユーザーのアクセストークンをそのまま転送**（Token Propagation）
* **Keycloak**でサービスごとのロール/スコープを発行しておく（例：`svc-a.read`, `svc-b.read`）
* **Kong**はルーティングとリダイレクトの起点（OIDCはQuarkusに任せる）

---

# 1) Keycloak の設定

1. 既存 `demo-realm` はそのまま使用

2. **クライアントを追加**

   * `quarkus-client`（既存/パブリック）：ユーザーがログインするときに使うフロントのclient
   * `service-a`（**confidential** でも **public** でもOK。今回はユーザートークン検証だけなので public でもよい）
   * `service-b`（同上）

3. **ロール/クライアントロール**の設計（どちらでもOK。簡単なのは“クライアントロール”）

   * `service-a` クライアントにロール `read` を作成
   * `service-b` クライアントにロール `read` を作成
   * ユーザー `testuser` に、**クライアントロール**

     * `service-a: read`
     * `service-b: read`
       を付与（またはグループ経由で付与でもOK）

> これで、発行されるアクセストークンの `resource_access.service-a.roles` と `resource_access.service-b.roles` に `read` が入るようになります。

4. `quarkus-client` の **Valid Redirect URIs** は **`http://localhost:8000/hello`**（Kong経由）を維持

---

# 2) Service A / B を追加（バックエンド）

### Compose 追記（例：両方 Quarkus）

```yaml
  service-a:
    build:
      context: ./service-a
      dockerfile: Dockerfile
    environment:
      QUARKUS_OIDC_AUTH_SERVER_URL: http://keycloak:8080/realms/demo-realm
      QUARKUS_OIDC_CLIENT_ID: service-a
      QUARKUS_OIDC_APPLICATION_TYPE: service
      # roles を access token から読み取る
      QUARKUS_OIDC_ROLES_SOURCE: access_token
      # Keycloakのクライアントロールの場所
      QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: resource_access["service-a"].roles
    ports:
      - "9081:8080"

  service-b:
    build:
      context: ./service-b
      dockerfile: Dockerfile
    environment:
      QUARKUS_OIDC_AUTH_SERVER_URL: http://keycloak:8080/realms/demo-realm
      QUARKUS_OIDC_CLIENT_ID: service-b
      QUARKUS_OIDC_APPLICATION_TYPE: service
      QUARKUS_OIDC_ROLES_SOURCE: access_token
      QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: resource_access["service-b"].roles
    ports:
      - "9082:8080"
```

> 外へ公開する必要がなければ `ports:` は省略可（Kong/集約APIから内部DNSで到達）。

### 各サービスの最低限コード例

```java
// service-a/src/main/java/.../AResource.java
@Path("/a/data")
@Produces(MediaType.APPLICATION_JSON)
public class AResource {

  @GET
  @RolesAllowed("read") // ← Keycloakの service-a クライアントロール read
  public Map<String, Object> data(@Context SecurityContext ctx) {
    return Map.of("from", "service-a", "user", ctx.getUserPrincipal().getName());
  }
}
```

```java
// service-b/src/main/java/.../BResource.java
@Path("/b/data")
@Produces(MediaType.APPLICATION_JSON)
public class BResource {
  @GET
  @RolesAllowed("read")
  public Map<String, Object> data(@Context SecurityContext ctx) {
    return Map.of("from", "service-b", "user", ctx.getUserPrincipal().getName());
  }
}
```

`application.properties`（両サービス共通の要点）：

```properties
quarkus.oidc.auth-server-url=${QUARKUS_OIDC_AUTH_SERVER_URL}
quarkus.oidc.client-id=${QUARKUS_OIDC_CLIENT_ID}
quarkus.oidc.application-type=service

# アクセストークン内のロールを使う
quarkus.oidc.roles.source=${QUARKUS_OIDC_ROLES_SOURCE}
quarkus.oidc.roles.role-claim-path=${QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH}
```

---

# 3) 集約 API（既存 Quarkus）に “マッシュアップ” を追加

## 依存追加（`pom.xml`）

* `quarkus-oidc`
* `quarkus-oidc-token-propagation`  ← これが**ユーザートークンを下流へ転送**してくれる
* `quarkus-rest-client-reactive-jackson`（REST呼び出し用）

## 設定（`quarkus-authz/application.properties` へ追記）

```properties
# REST Client の下流URL（内部DNSでOK）
quarkus.rest-client.service-a.url=http://service-a:8080
quarkus.rest-client.service-b.url=http://service-b:8080
```

## RESTクライアントIF

```java
// quarkus-authz/src/main/java/.../ServiceAClient.java
@RegisterRestClient(configKey = "service-a")
@Path("/a")
@Produces(MediaType.APPLICATION_JSON)
public interface ServiceAClient {
  @GET @Path("/data")
  Map<String, Object> getData();
}
```

```java
// quarkus-authz/src/main/java/.../ServiceBClient.java
@RegisterRestClient(configKey = "service-b")
@Path("/b")
@Produces(MediaType.APPLICATION_JSON)
public interface ServiceBClient {
  @GET @Path("/data")
  Map<String, Object> getData();
}
```

## 集約エンドポイント（多段認可）

```java
// quarkus-authz/src/main/java/.../MashupResource.java
@Path("/mashup")
@Produces(MediaType.APPLICATION_JSON)
public class MashupResource {

  @Inject
  @RestClient
  ServiceAClient serviceA;

  @Inject
  @RestClient
  ServiceBClient serviceB;

  // 入口の認証（未ログインなら Keycloak へ）
  @GET
  @RolesAllowed({"user"}) // 入口での最低ロール（必要に応じて）
  @io.quarkus.oidc.token.propagation.AccessToken // ← これが肝。ユーザートークンを下流に転送
  public Map<String, Object> mashup(@Context SecurityContext ctx) {
    var a = serviceA.getData(); // 下流Aで「service-a:read」を要求
    var b = serviceB.getData(); // 下流Bで「service-b:read」を要求
    return Map.of(
        "who", ctx.getUserPrincipal().getName(),
        "a", a,
        "b", b);
  }
}
```

> 入口では `@RolesAllowed("user")` 等で**一次認可**（「マッシュアップを呼ぶ資格があるか」）。
> 下流の A/B は自分の**クライアントロール `read` を要求**（**二段目の認可**）。
> これにより、ユーザーに **Aだけ**ロールがある場合は **Bで403** になり、全体のポリシーを制御できます。
> （要件次第で A/B の失敗時の扱いを try/catch で個別制御してください）

---

# 4) Kong のルーティング（/mashup を公開）

既存の `authz-service` を `/mashup` にも流用できます（上流URLは `/hello` のままでOK。アプリ内ルーティングで `/mashup` を処理）。
外部からは `/secure` を入口に、ログイン後 `/hello` or `/mashup` へ遷移します。

追加のルート作成：

```bash
# /mashup を Quarkus にルーティング
curl -i -X POST http://localhost:8001/services/authz-service/routes \
  --data paths[]=/mashup

# 必要なら preserve_host も有効化
M_ROUTE_ID=$(curl -s http://localhost:8001/routes | jq -r '.data[] | select(.paths|index("/mashup")) | .id')
curl -i -X PATCH http://localhost:8001/routes/$M_ROUTE_ID --data preserve_host=true

# （任意）/mashup にも session プラグイン
curl -i -X POST http://localhost:8001/routes/$M_ROUTE_ID/plugins \
  --data name=session \
  --data config.storage=kong \
  --data config.secret=$(openssl rand -hex 32) \
  --data config.cookie_samesite=Lax \
  --data config.cookie_http_only=true \
  --data config.cookie_secure=false
```

---

# 5) 動作確認シナリオ

1. ユーザー `testuser` に

   * `service-a: read` だけ付与 → `/mashup` は **A成功・B 403** になる想定
2. 両方 `read` を付与 → `/mashup` は **A/Bとも成功**して統合レスポンス
3. どちらのロールも無い → `/mashup` は**入口は通るが**下流で403（またはアプリ側で403前に弾く）

> 必要に応じて、**入口で “A/B の権限を内側でもチェック”** し、権限が足りない場合は**呼ぶ前に 403** を返す（＝完全に“段階式”）のも◎。

---

## よくある質問 / 追加Tips

* **Kongでスコープ検証はしないの？**
  OSS版だとOIDCプラグインが無いので、今回は**Quarkusに集約**しています（構成がシンプルで可観測性も高い）。
  Kong Enterprise の OIDC プラグインがあれば、Kongで**入口ポリシー**を実装 → さらに下流で**業務ポリシー**という分割も可能。

* **トークン交換（Token Exchange）が必要？**
  “ユーザーのトークンをそのまま A/B に渡す” 方式なら不要。
  “A/B 用の**別オーディエンス**のトークンにしたい” 場合は、Keycloak の Token Exchange を使って
  集約APIで**on-behalf-of**フロー → A/B は`aud=service-a|b`のアクセストークンを検証、という構成にできます。

* **ヘッダが大きくて 502**
  すでに入れた `kong-nginx-http.conf` のサイズを少し増やせばOK。

---

必要なら、**Service A/B の最小Quarkusプロジェクト雛形**や、**Token Exchange版のサンプル**も用意します。
どっちから行きます？


