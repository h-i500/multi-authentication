以下コードを解説してください。特に、このコードが認証認可の流れをどう考えているか、解説してください。

MashupResource.java
```
package org.example;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.HeaderParam;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;
import org.eclipse.microprofile.rest.client.inject.RestClient;

import io.quarkus.oidc.AccessTokenCredential;
import io.quarkus.security.identity.SecurityIdentity;

import io.quarkus.oidc.Tenant;


// @Tenant("svc")
@Tenant("service")
@Path("/mashup")
public class MashupResource {

    @RegisterRestClient(configKey = "service-a")
    public interface ServiceAClient {
    @GET @Path("/a/data")
    @Produces(MediaType.APPLICATION_JSON)
    ServiceAResponse call(@HeaderParam("Authorization") String authorization);
    }

    @RegisterRestClient(configKey = "service-b")
    public interface ServiceBClient {
    @GET @Path("/b/data")
    @Produces(MediaType.APPLICATION_JSON)
    ServiceBResponse call(@HeaderParam("Authorization") String authorization);
    }


    @Inject @RestClient ServiceAClient serviceA;
    @Inject @RestClient ServiceBClient serviceB;

    @Inject SecurityIdentity identity;

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public MashupResult mashup() {
    final String authHeader = bearer();
    try {
        ServiceAResponse a = serviceA.call(authHeader);
        ServiceBResponse b = serviceB.call(authHeader);
        MashupResult r = new MashupResult();
        r.fromServiceA = a; r.fromServiceB = b;
        return r;
    } catch (jakarta.ws.rs.WebApplicationException ex) {
        throw new jakarta.ws.rs.InternalServerErrorException(
        "downstream error: status=" + ex.getResponse().getStatus(), ex);
    } catch (Exception e) {
        throw new jakarta.ws.rs.InternalServerErrorException("downstream call failed: " + e, e);
    }
    }


    private String bearer() {
        var cred = identity.getCredential(AccessTokenCredential.class);
        var token = cred != null ? cred.getToken() : null;
        return token != null ? "Bearer " + token : null;
    }

    public static class ServiceAResponse { public String message; public String detail; }
    // public static class ServiceBResponse { public String message; public int count; }
    public static class ServiceBResponse { public String message; public String detail; }
    public static class MashupResult { public ServiceAResponse fromServiceA; public ServiceBResponse fromServiceB; }
}


```

application.properties
```
# quarkus.package.type=fast-jar

# ---
# ===== default (ブラウザログイン用) =====
quarkus.oidc.auth-server-url=http://keycloak:8080/realms/demo-realm
quarkus.oidc.client-id=quarkus-client
quarkus.oidc.application-type=web-app
quarkus.http.auth.permission.protected.paths=/hello
quarkus.http.auth.permission.protected.policy=authenticated
quarkus.http.proxy.proxy-address-forwarding=true

# ===== Bearer 専用テナント (svc) =====
# quarkus.oidc."svc".auth-server-url=http://keycloak:8080/realms/demo-realm
# quarkus.oidc."svc".client-id=quarkus-client
# quarkus.oidc."svc".application-type=service

# Named tenant "service"（Bearer）
quarkus.oidc."service".auth-server-url=http://keycloak:8080/realms/demo-realm
quarkus.oidc."service".client-id=quarkus-client
quarkus.oidc."service".application-type=service

# /mashup は Bearer で要認証
quarkus.http.auth.permission.mashup.paths=/mashup
quarkus.http.auth.permission.mashup.policy=authenticated

# Rest Client ベースURL（Docker サービス名）
quarkus.rest-client."service-a".url=http://service-a:8080
quarkus.rest-client."service-b".url=http://service-b:8080

# デバッグ（必要なら）
# quarkus.log.category."io.quarkus.oidc".level=DEBUG
# quarkus.log.category."org.jboss.resteasy.reactive.client".level=DEBUG

# OIDCの詳細ログ（集約側）
quarkus.log.category."io.quarkus.oidc".level=DEBUG

# RESTクライアントのログ（リクエスト/レスポンスを確認）
quarkus.rest-client.logging.scope=request-response
quarkus.rest-client.logging.body-limit=10240
quarkus.log.category."org.jboss.resteasy.reactive.client".level=DEBUG

# 自分のアプリのログ
quarkus.log.category."org.example".level=DEBUG

# quarkus.oidc.tenant-selection.key=X-Quarkus-Tenant

```

---

了解です。ポイントは「どのテナントで受け付けて」「どうやって下流サービスへトークンを渡して」「どこで認可（Authorization）をしている（or していない）のか」です。コードと `application.properties` を突き合わせて、認証認可の流れを分解して説明します。

---

# ざっくり結論

* \*\*受け口（このアプリ）**は Quarkus OIDC の**Bearer 専用テナント `"service"`\*\*で `/mashup` を受け付ける。
  → クライアントは **Authorization: Bearer \<access\_token>** を付けて呼ぶ必要がある。

* Quarkus がそのトークンを検証して **SecurityIdentity** を構築。`MashupResource` はそこから **AccessTokenCredential** を取り出して**同じトークンをそのまま下流（Service A/B）へ中継**している（**トークン・リレー**／**プロパゲーション**）。

* このコードでは**認可は「authenticated（ログイン済み）」のみ**。ロールやスコープの細かいチェックはしていない。下流も同じトークンを受けて各自で検証する前提。

---

# 具体的なリクエスト〜レスポンスの流れ

1. **クライアント → 集約 API（このアプリ）**

   * `GET /mashup` に **Authorization: Bearer <token>** を付けて呼ぶ。
   * `@Tenant("service")` により **このリソースクラスは常に `"service"` テナント**で処理される。
   * `application.properties` では:

     * `quarkus.oidc."service".application-type=service` → **Bearer-only（リダイレクトしない）**。
     * `quarkus.http.auth.permission.mashup.paths=/mashup` ＋ `policy=authenticated` → **/mashup はトークン必須**。

2. **トークン検証（認証）**

   * Quarkus OIDC は `auth-server-url=http://keycloak:8080/realms/demo-realm` の **Keycloak** に合わせて署名検証・期限確認・発行者/オーディエンス等をチェック。
   * 検証 OK なら **SecurityIdentity** が組み立てられ、`AccessTokenCredential`（アクセストークン文字列）も載る。

3. **アプリのビジネス処理**

   * `mashup()` 内で `bearer()` を呼び、`identity.getCredential(AccessTokenCredential.class)` から **アクセストークンの生文字列**を取得し、`"Bearer " + token` を作る。
   * MicroProfile Rest Client で定義した `ServiceAClient` / `ServiceBClient` に **同じ Authorization ヘッダー**を付けて呼び出す：

     ```java
     ServiceAResponse a = serviceA.call(authHeader);
     ServiceBResponse b = serviceB.call(authHeader);
     ```
   * つまり \*\*「受けたトークンをそのまま下流へ中継」\*\*している（**Token Relay**）。トークン交換や再発行はしていない。

4. **下流サービス（Service A / B）側**

   * Service A/B も **Bearer トークンを受け取り、同じ Keycloak（同一 realm）で検証**して有効なら応答。
   * 返ってきた JSON をまとめて `MashupResult` に詰めて返す。

---

# コードの見どころ（認証・認可の観点）

### 1. テナント選択：`@Tenant("service")`

```java
// @Tenant("svc")
@Tenant("service")
@Path("/mashup")
public class MashupResource { ... }
```

* このアノテーションで **このクラス配下は “service” テナントの設定で処理**されます。
* `"service"` テナントは `application-type=service`（Bearer 専用、リダイレクトなし）。
* コメントアウトされている `"svc"` は別名テナントの試行痕跡。実際は `"service"` を使用。

> 補足：`quarkus.oidc.tenant-selection.key=X-Quarkus-Tenant` を使うと**ヘッダーで動的にテナント切替**もできますが、ここでは**固定**です。

### 2. エンドポイント保護：`authenticated` ポリシー

```properties
quarkus.http.auth.permission.mashup.paths=/mashup
quarkus.http.auth.permission.mashup.policy=authenticated
```

* ここで **/mashup は認証必須**に。
* **ロール指定はなし**なので「**誰でも、正しいトークンを持っていれば通過**」という認可モデルです。

> 厳密な権限制御が必要なら、`@RolesAllowed("...")` や `quarkus.http.auth.permission.*.roles-allowed=...` を追加します。

### 3. トークンの取り出しと下流への中継

```java
private String bearer() {
    var cred = identity.getCredential(AccessTokenCredential.class);
    var token = cred != null ? cred.getToken() : null;
    return token != null ? "Bearer " + token : null;
}
```

* **SecurityIdentity から AccessTokenCredential を引き抜き**、**Authorization ヘッダーを自前で作成**。
* そのまま **Rest Client のメソッドパラメータ @HeaderParam("Authorization")** に渡しています。
* これは Quarkus の **「トークン伝播」**を**手動**でやっている形。

  * 代替案として、`quarkus-oidc-token-propagation` / `oidc-client-filter` などの**自動伝播**を使う方法もあります。

### 4. Rest Client の定義

```java
@RegisterRestClient(configKey = "service-a")
public interface ServiceAClient {
  @GET @Path("/a/data")
  @Produces(MediaType.APPLICATION_JSON)
  ServiceAResponse call(@HeaderParam("Authorization") String authorization);
}
```

* `application.properties` の

  ```properties
  quarkus.rest-client."service-a".url=http://service-a:8080
  quarkus.rest-client."service-b".url=http://service-b:8080
  ```

  と対応。**Docker 内の別サービス**へベース URL 指定でアクセス。

### 5. エラーハンドリング

```java
} catch (jakarta.ws.rs.WebApplicationException ex) {
  throw new jakarta.ws.rs.InternalServerErrorException(
    "downstream error: status=" + ex.getResponse().getStatus(), ex);
}
```

* 下流が 401/403/500 を返しても**上流で一律 500 に包み直し**。

  * セキュリティ上の情報漏えいは抑えられる一方、**本来 401/403 を返すべきケースも 500 になる**ので、クライアントにとっては状況が分かりづらい。
  * 可能なら **401/403 はそのまま伝達**、それ以外だけ 500 にする等が実運用向け。

---

# この構成での「認証」「認可」の考え方

* **認証（Authentication）**

  * Keycloak の **Access Token（JWT）** を **Bearer** として受け取り、**“service” テナント**設定で検証する。
  * 検証 OK なら `SecurityIdentity` が確立。ここで**ユーザーやロール、クレーム**がそろう。

* **認可（Authorization）**

  * **このコードでは「authenticated」だけ**を要求。
  * つまり**有効なトークンなら誰でも /mashup に到達**できる。
  * さらに**下流への呼び出しでも追加のロール／スコープチェックはしていない**（単にトークン中継）。
  * 厳格化したい場合は：

    * 上流（この API）で **@RolesAllowed** や `identity.hasRole(...)` で**事前フィルタ**。
    * 下流でも **audience / scope / role** をチェック（Keycloak 側のクライアント設定も含めて）。
    * 例えば「`scope:serviceA.read` が無ければ A は呼ばない」といった分岐。

---

# 気をつけたい実装ポイント（改善提案）

1. **パスのマッチング**

   * `paths=/mashup` だと**ちょうど `/mashup` のみ**に適用。将来 `/mashup/health` 等を増やすなら `paths=/mashup*` を検討。

2. **ロール／スコープの明示的チェック**

   * たとえば：

     ```java
     @RolesAllowed({"mashup:read"})
     @GET
     public MashupResult mashup() { ... }
     ```
   * あるいは `if (!identity.hasRole("mashup:read")) { throw new ForbiddenException(); }` 等。

3. **aud / resource\_access の整合性**

   * 下流が同じトークンを受けるには、**同一 realm** で **aud（audience）** などの条件が合う必要がある。Keycloak の**クライアント設定**（`quarkus-client`）や**サービス側のアダプタ設定**を確認。

4. **エラーマッピング**

   * 401/403 は上流でも **同じステータスで返す**とクライアントがリトライ/再認証判断しやすい。
   * ログには `ex.getResponse().readEntity(String.class)` で**下流エラーボディ**を出して、クライアントへは簡潔なメッセージだけ返すなど。

5. **自動トークン伝播の活用（任意）**

   * 手書きでヘッダーを渡す代わりに、Quarkus の **Token Propagation** フィルタを使えば、**Rest Client 呼び出しに自動で Authorization を載せる**構成にできる。
   * 複数クライアントやエンドポイントが増えると保守性が上がる。

6. **トークン期限切れ**

   * 期限切れなら下流から 401 が返る → 現在は 500 包装。
   * 上記のエラーマッピング改善と合わせて、**期限切れは 401** を返すとよい。

---

# まとめ（このコードの意図）

* **/mashup を Bearer トークン必須**（“service” テナント）にして**受け**、
* **受け取ったトークンをそのまま下流 A/B に中継**して**合成結果を返す**、という**シンプルなトークン・リレーの集約 API**。
* いまのところ**認可は最小限（authenticated）**で、**細かな権限判定は未実装**。必要に応じて**ロール／スコープ／audience**をチェックし、**エラーマッピング**や**自動伝播**を整えると堅牢になります。

必要なら、ロールベースの例や Token Propagation の設定例もこちらで書き起こします。


---

下流のservice-aは以下のような実装です。
AResource.java
```
package org.example;

// import jakarta.annotation.security.RolesAllowed;
// import jakarta.ws.rs.Path;
// import jakarta.ws.rs.Produces;
// import jakarta.ws.rs.core.Context;
// import jakarta.ws.rs.core.MediaType;
// import jakarta.ws.rs.core.SecurityContext;
// import jakarta.ws.rs.GET;
// import java.util.Map;

// import org.example.AResource.AResp;

// import io.quarkus.security.identity.SecurityIdentity;
// import jakarta.inject.Inject;

// service-a/src/main/java/.../AResource.java
// @Path("/a/data")
// @Produces(MediaType.APPLICATION_JSON)
// public class AResource {

//   @GET
//   @RolesAllowed("read") // ← Keycloakの service-a クライアントロール read
//   public Map<String, Object> data(@Context SecurityContext ctx) {
//     return Map.of("from", "service-a", "user", ctx.getUserPrincipal().getName());
//   }
// }


// @Path("/a/data")
// @Produces(MediaType.APPLICATION_JSON)
// public class AResource {
//   @GET
//   @RolesAllowed("read")
//   public Map<String,Object> data(@Context SecurityContext ctx) {
//     return Map.of("from","service-a","user",ctx.getUserPrincipal().getName());
//   }
// }


import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/a")
public class AResource {
  @GET
  @Path("/data")
  @Produces(MediaType.APPLICATION_JSON)
  public AResp get() {
    var r = new AResp();
    r.message = "ok-from-A";
    r.detail = "helloA";
    return r;
  }
  public static class AResp { public String message; public String detail; }
}


```

application.properties
```
# quarkus.package.type=fast-jar

quarkus.oidc.auth-server-url=${QUARKUS_OIDC_AUTH_SERVER_URL}
quarkus.oidc.client-id=${QUARKUS_OIDC_CLIENT_ID}
quarkus.oidc.application-type=service

# アクセストークン内のロールを使う
quarkus.oidc.roles.source=${QUARKUS_OIDC_ROLES_SOURCE}
quarkus.oidc.roles.role-claim-path=${QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH}
```

また、全体をdocker-composeで環境変数を設定しながら立ち上げています。
```
version: '3.8'

services:
  kong-database:
    image: postgres:10  # ← バージョン10に変更
    environment:
      POSTGRES_USER: kong
      POSTGRES_DB: kong
      POSTGRES_PASSWORD: kong
    volumes:
      - kong_data:/var/lib/postgresql/data
      - ./init-konga-db.sql:/docker-entrypoint-initdb.d/init-konga-db.sql

  redis:
    image: redis:7
    ports:
      - "6379:6379"

  kong:
    image: kong:3.6.0
    depends_on:
      - kong-database
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: kong-database
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: kong
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: 0.0.0.0:8001
      KONG_PLUGINS: bundled
      # ← 追加：httpコンテキストにインクルード
      KONG_NGINX_HTTP_INCLUDE: /usr/local/kong/nginx-http.conf
    ports:
      - "8000:8000"  # Proxy
      - "8001:8001"  # Admin API
    command: ["kong", "docker-start"]
    volumes:
      - ./kong-nginx-http.conf:/usr/local/kong/nginx-http.conf:ro

  konga:
    image: pantsel/konga:latest
    container_name: konga
    restart: always
    environment:
      - NODE_ENV=development
      #- NODE_ENV=production
      - DB_ADAPTER=postgres
      - DB_HOST=kong-database
      - DB_USER=kong
      - DB_PASSWORD=kong
      - DB_DATABASE=konga
    ports:
      - "1337:1337"
    depends_on:
      - kong-database
    
  keycloak:
    image: quay.io/keycloak/keycloak:24.0
    command: start-dev
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
    ports:
      - "8080:8080"

  quarkus-authz:
    build:
      context: ./quarkus-authz
      dockerfile: Dockerfile
    depends_on:
      - redis
    environment:
      REDIS_HOST: redis
      QUARKUS_LOG_CATEGORY__IO_QUARKUS_OIDC__LEVEL: DEBUG
    ports:
      - "8081:8080"


  service-a:
    build:
      context: ./service-a
      dockerfile: Dockerfile
    environment:
      QUARKUS_OIDC_AUTH_SERVER_URL: http://keycloak:8080/realms/demo-realm
      QUARKUS_OIDC_CLIENT_ID: service-a
      QUARKUS_OIDC_APPLICATION_TYPE: service
      QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_PATHS: /a/*
      QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_POLICY: authenticated

      # QUARKUS_OIDC_ROLES_SOURCE: accesstoken
      # QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: resource_access."service-a".roles
      # QUARKUS_OIDC_ROLES_SOURCE: accesstoken
      # QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: resource_access."service-a".roles
      # QUARKUS_OIDC_ROLES_SOURCE: accesstoken
      # QUARKUS_OIDC_ROLES_SOURCE: access_token
      # QUARKUS_OIDC_ROLES_SOURCE: access-token
      QUARKUS_OIDC_ROLES_SOURCE: accesstoken
      QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: 'resource_access["service-a"].roles'

      # ← 追加：デバッグログ
      QUARKUS_LOG_LEVEL: INFO
      QUARKUS_LOG_CATEGORY__IO_QUARKUS_OIDC__LEVEL: DEBUG
      QUARKUS_LOG_CATEGORY__IO_QUARKUS_SECURITY__LEVEL: DEBUG
    ports: ["9081:8080"]

  service-b:
    build:
      context: ./service-b
      dockerfile: Dockerfile
    environment:
      QUARKUS_OIDC_AUTH_SERVER_URL: http://keycloak:8080/realms/demo-realm
      QUARKUS_OIDC_CLIENT_ID: service-b
      QUARKUS_OIDC_APPLICATION_TYPE: service
      QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_PATHS: /b/*
      QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_POLICY: authenticated

      # QUARKUS_OIDC_ROLES_SOURCE: accesstoken
      # QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: resource_access."service-b".roles
      # QUARKUS_OIDC_ROLES_SOURCE: accesstoken
      # QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: resource_access."service-b".roles
      # QUARKUS_OIDC_ROLES_SOURCE: accesstoken
      # QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: 'resource_access["service-b"].roles'
      # QUARKUS_OIDC_ROLES_SOURCE: access_token
      # QUARKUS_OIDC_ROLES_SOURCE: access-token
      QUARKUS_OIDC_ROLES_SOURCE: accesstoken
      QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH: 'resource_access["service-b"].roles'

      # ← 追加：デバッグログ
      QUARKUS_LOG_LEVEL: INFO
      QUARKUS_LOG_CATEGORY__IO_QUARKUS_OIDC__LEVEL: DEBUG
      QUARKUS_LOG_CATEGORY__IO_QUARKUS_SECURITY__LEVEL: DEBUG
    ports: ["9082:8080"]


volumes:
  kong_data:
```

下流でも"認可"は出来ていないでしょうか？

---

結論から言うと、**いまの `service-a` は「認証は必須」だが「認可（RBAC）」は効いていません。**
理由は以下のとおりです。

---

## いま実際に起きていること

* `docker-compose` の環境変数で：

  ```ini
  QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_PATHS=/a/*
  QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_POLICY=authenticated
  ```

  を指定しています。これは **「/a/* へのリクエストは *認証済み* なら通す」*\* という設定で、**ロール条件は無し**です。

* コード側の `AResource` は以下のとおりで、**`@RolesAllowed` がコメントアウト**されています：

  ```java
  @Path("/a")
  public class AResource {
    @GET @Path("/data")
    @Produces(MediaType.APPLICATION_JSON)
    public AResp get() { ... }
  }
  ```

  → **メソッド／クラスどちらにもロール制約が無い**ため、**有効なトークンでさえあれば誰でも通る**状態です。

* たしかにロール抽出向けの設定は入っています（`QUARKUS_OIDC_ROLES_SOURCE=accesstoken` と `QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH='resource_access["service-a"].roles'`）。
  しかし **ロールを“使って”制御する箇所が無い**（＝`@RolesAllowed` か `roles-allowed` を設定していない）ので、**下流では認可が未実施**です。

---

## 認可（RBAC）を有効化するには

### 方法A：コードで付ける（推奨）

`@RolesAllowed("read")` を復活させます。

```java
@Path("/a")
public class AResource {

  @GET
  @Path("/data")
  @Produces(MediaType.APPLICATION_JSON)
  @RolesAllowed("read")  // ← これを有効にする
  public AResp get(@Context SecurityContext ctx) { ... }
}
```

* これで **アクセストークンに `resource_access["service-a"].roles` に `"read"` が含まれる場合のみ 200**、無ければ **403 Forbidden** になります。
* すでに役割抽出の設定は入っているので（`accesstoken` + role-claim-path）、**Keycloak 側でユーザー（またはクライアント・ロールの付与）だけ整えば動作**します。

### 方法B：設定で付ける（アノテーション不要）

環境変数（または `application.properties`）で **roles-allowed** を指定します。

```ini
QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_PATHS=/a/*
QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_POLICY=authenticated
QUARKUS_HTTP_AUTH_PERMISSION_PROTECTED_ROLES_ALLOWED=read
```

* これで \**/a/* に `"read"` ロール必須\*\*となります。
* コード変更なしで適用できますが、**細かいメソッド単位の制御はアノテーションの方がやりやすい**です。

> どちらの方法でも OK。**併用しても矛盾しません**（厳しい方に揃います）。

---

## Keycloak 側のチェックポイント

1. **ロール付与**

   * `service-a` クライアントに **クライアント・ロール `read`** を作成。
   * ユーザーにそのロールを割り当て（またはグループ経由）。
   * そのうえで発行されるアクセストークンに

     ```json
     "resource_access": {
       "service-a": {
         "roles": ["read", ...]
       }
     }
     ```

     が入っていることを確認。

2. **`roles.source` / `role-claim-path` の整合**

   * いまの指定：

     ```
     QUARKUS_OIDC_ROLES_SOURCE=accesstoken
     QUARKUS_OIDC_ROLES_ROLE_CLAIM_PATH=resource_access["service-a"].roles
     ```

     は正しい形です（`accesstoken` のスペルもこれでOK）。
   * もし名前付きテナント等で path が変わる場合は都度見直し。

3. **audience の扱い（任意だが重要）**

   * いまは上流のトークンをそのままリレーしています（`quarkus-authz` → `service-a`）。
   * デフォルトでは **Quarkus は `aud` を必須チェックしません**。同一 realm のトークンなら通るため、**厳密性が足りない**と感じたら `service-a` 側で **期待オーディエンス**を明示します：

     ```ini
     quarkus.oidc.token.audience=service-a
     ```

     など（複数可）。Keycloak 側で **audience に `service-a` が入るようマッパーやクライアントスコープを設定**します。
   * さらに厳格にするなら **Token Exchange** で「各下流サービス用のトークンに交換」してから渡す方式もあります（今回は単純リレー）。

---

## よくあるハマりどころ

* **ロールは出ているのに 403**：
  → `roles.source` / `role-claim-path` が一致しているか、ロール名のミスマッチ（`read` vs `READ`）を確認。
* **常に通ってしまう**：
  → `@RolesAllowed` を付け忘れている / `roles-allowed` が未設定。
* **`aud` チェックで 401 になる**：
  → `quarkus.oidc.token.audience` を設定したのに、Keycloak のトークンに該当の aud が入っていない。

---

## まとめ

* \*\*現在の `service-a` は「認証のみ」\*\*です。
* **`@RolesAllowed("read")` を付ける**か、**`roles-allowed=read` を設定**すれば、**トークン内ロールに基づく「認可」が有効**になります。
* 併せて **`aud` を厳格化**すると、\*\*「そのサービス向けのトークンだけを受け付ける」\*\*堅牢な構成になります。
* `service-b` も同じ考え方で設定すれば OK です。

必要なら、`service-b` 含めた最小差分パッチ（コード＋compose環境変数）も書きます。
